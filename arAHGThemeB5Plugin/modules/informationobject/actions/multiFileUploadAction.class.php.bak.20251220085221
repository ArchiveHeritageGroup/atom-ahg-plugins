<?php
use AtomExtensions\Services\AclService;

/*
 * This file is part of the Access to Memory (AtoM) software.
 *
 * Modified by The AHG to include Universal Metadata Extraction
 * Supports: EXIF, IPTC, XMP (images), PDF metadata, Office documents,
 * Video metadata, Audio ID3 tags, and Face Detection
 *
 * Access to Memory (AtoM) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

// Include the metadata extraction trait
require_once sfConfig::get('sf_lib_dir').'/arMetadataExtractionTrait.php';

class InformationObjectMultiFileUploadAction extends sfAction
{
    // Use the universal metadata extraction trait
    use arMetadataExtractionTrait;

    public function execute($request)
    {
        $this->form = new sfForm();
        $this->form->getValidatorSchema()->setOption('allow_extra_fields', true);

        $this->resource = $this->getRoute()->resource;

        // Check that object exists and that it is not the root
        if (!isset($this->resource) || !isset($this->resource->parent)) {
            $this->forward404();
        }

        // Check user authorization
        if (!AclService::check($this->resource, 'update') && !$this->getUser()->hasGroup(QubitAclGroup::EDITOR_ID)) {
            AclService::forwardUnauthorized();
        }

        // Check if uploads are allowed
        if (!QubitDigitalObject::isUploadAllowed()) {
            AclService::forwardToSecureAction();
        }

        // Get max upload size limits
        $this->maxFileSize = QubitDigitalObject::getMaxUploadSize();
        $this->maxPostSize = QubitDigitalObject::getMaxPostSize();

        // Paths for uploader javascript
        $this->uploadResponsePath = "{$this->context->routing->generate(null, ['module' => 'digitalobject', 'action' => 'upload'])}?".http_build_query(['informationObjectId' => $this->resource->id]);

        // Add digital object JavaScript
        $this->response->addJavascript('/vendor/jquery.multifile', 'last');

        // Add form fields
        $this->addFormFields();

        if ($request->isMethod('post')) {
            $this->processForm($request);
        }
    }

    protected function addFormFields()
    {
        // Title field
        $this->form->setValidator('title', new sfValidatorString(['required' => false]));
        $this->form->setWidget('title', new sfWidgetFormInput());

        // Level of description
        $this->form->setValidator('levelOfDescription', new sfValidatorString(['required' => false]));
        $this->form->setWidget('levelOfDescription', new sfWidgetFormSelect([
            'choices' => QubitTerm::getLevelsOfDescription(),
        ]));
    }

    protected function processForm($request)
    {
        // Get the parent information object
        $parent = $this->resource;

        // Get uploaded files
        $uploadIds = $request->getParameter('uploadId', []);
        $titles = $request->getParameter('title', []);
        $levelOfDescriptions = $request->getParameter('levelOfDescription', []);

        if (!is_array($uploadIds)) {
            $uploadIds = [$uploadIds];
            $titles = [$titles];
            $levelOfDescriptions = [$levelOfDescriptions];
        }

        $uploadDir = sfConfig::get('sf_upload_dir').'/tmp';
        $processedCount = 0;
        $errorCount = 0;

        foreach ($uploadIds as $index => $uploadId) {
            if (empty($uploadId)) {
                continue;
            }

            $uploadFile = $uploadDir.'/'.$uploadId;

            if (!is_readable($uploadFile)) {
                $errorCount++;
                error_log("Multi-upload: Cannot read file {$uploadId}");
                continue;
            }

            try {
                // Create child information object
                $informationObject = new QubitInformationObject();
                $informationObject->parentId = $parent->id;

                // Set title from form or filename
                $title = !empty($titles[$index]) ? $titles[$index] : $uploadId;
                $informationObject->setTitle($title);

                // Set level of description
                if (!empty($levelOfDescriptions[$index])) {
                    $informationObject->levelOfDescriptionId = $levelOfDescriptions[$index];
                }

                // Set publication status to draft
                $informationObject->setPublicationStatus(QubitTerm::PUBLICATION_STATUS_DRAFT_ID);

                // Save information object first
                $informationObject->save();

                // Create digital object
                $digitalObject = new QubitDigitalObject();
                $digitalObject->usageId = QubitTerm::MASTER_ID;
                $digitalObject->informationObjectId = $informationObject->id;

                // Get file content
                $content = file_get_contents($uploadFile);
                $originalName = $request->getParameter('name')[$index] ?? $uploadId;

                // Set asset
                $digitalObject->setAsset($originalName, $content);
                $digitalObject->save();

                // Get the saved file path for metadata extraction
                $savedFilePath = sfConfig::get('sf_web_dir').$digitalObject->path;

                // =============================================================
                // UNIVERSAL METADATA EXTRACTION
                // =============================================================
                error_log("=== MULTI-FILE UPLOAD - METADATA EXTRACTION ===");
                error_log("File {$index}: " . $originalName);

                // Extract all metadata from original temp file (better quality)
                $metadata = $this->extractAllMetadata($uploadFile);

                if ($metadata) {
                    // Apply metadata to information object
                    $this->applyMetadataToInformationObject(
                        $informationObject,
                        $metadata,
                        $digitalObject
                    );

                    // Override title with metadata title if form title was empty
                    $keyFields = $metadata['_extractor']['key_fields'] ?? [];
                    if (empty($titles[$index]) && !empty($keyFields['title'])) {
                        $informationObject->setTitle($keyFields['title']);
                        $informationObject->save();
                        error_log("Title set from metadata: " . $keyFields['title']);
                    }

                    // Process face detection if enabled and this is an image
                    $fileType = $metadata['_extractor']['file_type'] ?? null;
                    if ($fileType === 'image') {
                        $this->processFaceDetection($uploadFile, $informationObject, $digitalObject);
                    }
                }

                // Clean up temp file
                if (is_writable($uploadFile)) {
                    unlink($uploadFile);
                }

                $processedCount++;

            } catch (Exception $e) {
                $errorCount++;
                error_log("Multi-upload error for file {$index}: " . $e->getMessage());

                // Clean up temp file even on error
                if (is_writable($uploadFile)) {
                    unlink($uploadFile);
                }
            }
        }

        // Set flash message
        if ($processedCount > 0) {
            $this->getUser()->setFlash('notice', sprintf(
                'Successfully uploaded %d file(s)%s',
                $processedCount,
                $errorCount > 0 ? " ({$errorCount} error(s))" : ''
            ));
        } elseif ($errorCount > 0) {
            $this->getUser()->setFlash('error', 'Failed to upload files');
        }

        // Redirect to parent
        $this->redirect([$parent, 'module' => 'informationobject']);
    }
}